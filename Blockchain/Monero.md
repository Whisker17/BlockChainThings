# Monero

## 设计理念

- 环签名（Ring Signature），用于发送方，具有不可追踪的效果

- 混淆地址（Stealth Address），用于接收方，具有不可追踪的效果

- 环机密交易，做到交易金额的隐匿
- 钥匙镜像，从而解决双花问题
- 私人交易数据，做到不可分析的效果
- 区块大小、挖矿难度能够自我动态调整
- 更加平等的挖矿算法

## Stealth Address

首先我们要确定的是，为什么我们需要 Stealth Address 。我们来假设一个这样的场景：

Alice 是一家店铺的店主，她可以接受各种数字货币，比如 BTC ， ETH 之类的。那么她的所有的账目都是可以通过她的收款地址来得到，这样作为商业对手的 Bob 等人就可以通过查询该地址的流水来对 Alice 进行价格上的攻击。于是，对于交易的隐私性就孕育而生了。

区别于 Bitcoin ， Monero 的地址是通过两对公钥组成。 spend 是一部分， view 是另一部分。

一个 Monero 的标准地址如下所示：

```
network byte 18 + public spend key + public view key + checksum
```

前面是网络编码（可简单理解为前缀），中间是公开支付钥匙 + 公开查看钥匙，后面是校验和（可简单理解为后缀）。

而对于 Stealth Address 来说，我们的创建方式是：

`P = Hs(rA)G + B`

对于上面这个式子，我们来解析一下：

1.  P ——最终的 Stealth Address ，即我们在交易中最终币打向的地址，是一个一次性地址。
2.  Hs ——一个hash的函数，返回一个 scalar 。
3.  r ——一个随机数，由发送方生成，且不公开。
4.  A ——接收方的 view 公钥
5.  G ——Ed25519的基点
6.  B ——接收方的 spend 公钥

那么，一笔这样的隐私交易的过程如下：

1. Bob需要选取两个数 a和b作为私钥，并在ECC椭圆曲线上计算出对应的公钥 A和B。A=aG, B=bG，G是曲线上一个公用的基点。然后Bob将计算出来的这两个公钥A、B向全网公布。
2. 现在Alice想向给Bob发起一笔交易，需要先获取到Bob公布的公钥A、B，然后选取一个随机整数r作为另一个私钥，通过公式 P=Hs(rA)G+B，计算出公开地址P。
3. Alice再通过公式 R=rG，将随机整数r转换成R
4. Alice创建转账交易，并将计算出的R、P一起记录到交易中公布到区块链上。由于使用了哈希函数，所以根据R、P是无法推断出A、B，从而无法获悉接收人是Bob。
5. Bob扫描区块链上的交易，根据公式 P'=Hs(aR)G+bG 计算P'，如果交易的接收人是Bob，根据aR = arG = rA，所以P'= Hs(aR)G+B = Hs(rA)G+B = P，也就是检测到P'=P时，就可以认为这笔交易是发给Bob的。
6. Bob根据公式 x=Hs(aR)+b，计算得到一个整数，因为有 xG = Hs(aR)G+bG = Hs(aR)G+B = P, 符合ECC算法定义，x就是针对公钥P的私钥，而这个私钥连给钱的Alice也无法推算出。日后Bob就可以使用这个私钥来花费这笔钱了。