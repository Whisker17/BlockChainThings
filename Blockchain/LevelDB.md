# LevelDB

**一句话说，LevelDB是一款基于LSM树的持久化存储的KV数据库，具有极佳的写功能。**

LSM树的核心思想就是**放弃部分读的性能，换取最大的写入能力**。

LSM树写性能极高的原理，简单地来说就是**尽量减少随机写的次数**。对于每次写入操作，并不是直接将最新的数据驻留在磁盘中，而是将其拆分成**（1）一次日志文件的顺序写（2）一次内存中的数据插入**。LevelDB正是实践了这种思想，将数据首先更新在内存中，当内存中的数据达到一定的阈值，将这部分数据真正刷新到磁盘文件中，因而获得了极高的写性能

## 整体架构

![LevelDB_1](./pics/LevelDB_1.png)

如上图所示，LevelDB共有六个成分组成：

1. Memtable
2. Immutable memtable
3. Log
4. Sstable
5. Manifest
6. Current

## 基本概念

### Memtable

DB数据在内存中的存储方式，写操作会先写入memtable，memtable是处在内存中的，所以效率非常高，但是由于内存容量是有限的，并且价格比较贵，所以我们会在达到阈值（默认为4MB）之后进行一个持久化的过程，变成只读的memtable(**immutable memtable**)，相关内容我们在下文继续介绍。

* **SkipList**

  SkipList本质上也是一种查找结构，用于解决算法中的查找问题，即根据给定的key，快速查到他所在的位置（或者对应的value）。

  SkipList，顾名思义，是一个list，事实上，它是在有序链表的基础上发展起来的。

  我们首先先来看一个有序链表：

  ![SkipList_1](./pics/SkipList_1.jpg)

  在这样的链表中，我们去查询某个数据的话，需要的是从头开始遍历，时间复杂度为O(n)。

  假如我们每相邻两个节点增加一个指针，让指针指向下下个节点，如下图：

  ![SkipList_2](./pics/SkipList_2.png)

  那么，在新的一层中，节点数就会下降到原先的一半（即7,19,26），还是从头开始遍历，但是数量减少了。当我们想要查找某个数据时，先沿着新的链表查询，当碰到比待查询数据大的节点时，再回到原来的节点去查询，例如我们想要查找23，查询路径即为红线：

  ![SkipList_2](./pics/SkipList_3.png)

  同样的，我们还可以继续再多建一层链表，进一步减少查询的次数。可以想象，当链表足够长的时候，这种多层链表的查找方式能让我们跳过很多下层节点，大大加快查找的速度。

  实际上，按照上面生成链表的方式，上面每一层链表的节点个数，是下面一层的节点个数的一半，这样查找过程就非常类似于一个**二分查找**，使得查找的时间复杂度可以降低到O(log n)。但是，**这种方法在插入数据的时候有很大的问题**。新插入一个节点之后，就会打乱上下相邻两层链表上节点个数严格的2:1的对应关系。如果要维持这种对应关系，就必须把新插入的节点后面的所有节点（也包括新插入的节点）重新进行调整，这会让时间复杂度重新蜕化成O(n)。删除数据也有同样的问题。

  SkipList为了避免这一问题，**它不要求上下相邻两层链表之间的节点个数有严格的对应关系**，而是为每个节点随机出一个层数(level)。比如，一个节点随机出的层数是3，那么就把它链入到第1层到第3层这三层链表中。为了表达清楚，下图展示了如何通过一步步的插入操作从而形成一个SkipList的过程：

  ![SkipList_2](./pics/SkipList_4.png)

  * **SkipList和平衡树、哈希表的比较**
    - **SkipList和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。**因此，在哈希表上只能做单个key的查找，不适宜做范围查找。所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。
    - 在做范围查找的时候，平衡树比SkipList操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在SkipList上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。
    - 平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而SkipList的插入和删除只需要修改相邻节点的指针，操作简单又快速。
    - 从内存占用上来说，SkipList比平衡树更灵活一些。**一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而SkipList每个节点包含的指针数目平均为1/(1-p)，**具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。
    - 查找单个key，SkipList和平衡树的时间复杂度都为O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。
    - 从算法实现难度上来比较，SkipList比平衡树要简单得多。

### immutable Memtable

memtable的容量到达阈值时，便会转换成一个不可修改的memtable，也称为immutable memtable。这两者的结构定义完全一样，区别只是immutable memtable是只读的。当一个immutable memtable被创建时，leveldb的后台压缩进程便会将利用其中的内容，创建一个sstable，持久化到磁盘文件中。

### Log

前面说过，LevelDB是基于WAL的，所以这里的log就是在写操作过程中率先写入的组件，当以下异常情况发生时，均可以通过日志文件进行恢复：

1. 写log期间进程异常
2. 写log完成，写内存未完成；
3. write动作完成（即log、内存写入都完成）后，进程异常；
4. Immutable Memtable持久化过程中进程异常
5. 其他压缩异常（较为复杂，首先不在这里介绍）

当第一类情况发生时，数据库重启读取log时，发现异常日志数据，抛弃该条日志数据，即视作这次用户写入失败，保障了数据库的一致性；

当第二类，第三类，第四类情况发生了，均可以通过redo日志文件中记录的写入操作完成数据库的恢复。

每次日志的写操作都是一次顺序写，因此写效率高，整体写入性能较好。

## 读写操作

### 写操作

![SkipList_2](./pics/SkipList_5.png)

首先我们要确认的是，LevelDB是一个基于**WAL**（**Write-ahead Log**）的存储系统，即先写日志数据，后写用户数据，这样就可以保证用户数据的持久化。在数据库意外宕机时，可以利用WAL恢复到宕机前的状态